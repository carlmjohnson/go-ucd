// The following directive is necessary to make the package coherent:

// +build ignore

// This program generates unihan.go. It can be invoked by running
// go generate
package main

import (
	"archive/zip"
	"bytes"
	"encoding/csv"
	"errors"
	"flag"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strings"
	"text/template"
	"time"
)

const unihanURL = "http://unicode.org/Public/UCD/latest/ucd/Unihan.zip"

func getUnihanFile() ([]byte, error) {
	rsp, err := http.Get(unihanURL)
	if err != nil {
		return nil, err
	}

	defer rsp.Body.Close()

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	return body, nil
}

func getUnihanZipReader(b []byte) (*zip.Reader, error) {
	reader, err := zip.NewReader(bytes.NewReader(b), int64(len(b)))
	if err != nil {
		return nil, err
	}

	return reader, nil
}

var noFileError = errors.New("No file 'Unihan_Readings.txt' in the provided zip file.")

func getUnihanReaderFromZip(reader *zip.Reader) (io.Reader, error) {
	for _, zf := range reader.File {
		if zf.Name != "Unihan_Readings.txt" {
			continue
		}

		src, err := zf.Open()

		if err != nil {
			return nil, err
		}

		defer src.Close()

		// Copying the file so we can go ahead and close the zip file
		var buf bytes.Buffer

		_, err = io.Copy(&buf, src)

		return &buf, err
	}

	return nil, noFileError
}

type UnihanRecord struct {
	Codepoint, Definition string
}

func getUnihanRecords(r io.Reader) ([]UnihanRecord, error) {
	reader := csv.NewReader(r)
	reader.Comma = '\t'
	reader.FieldsPerRecord = 3
	reader.Comment = '#'

	records := make([]UnihanRecord, 0)

	for {
		record, err := reader.Read()

		if err == io.EOF {
			return records, nil
		} else if err != nil {
			return nil, err
		}
		if record[1] == "kDefinition" {
			codepoint := strings.TrimPrefix(record[0], "U+")
			definition := strings.ToUpper(record[2])

			records = append(records, UnihanRecord{codepoint, definition})
		}
	}
}

const templateString = `// go generate
// GENERATED BY THE COMMAND ABOVE; DO NOT EDIT

// This file was generated by robots at
// {{ .Timestamp }}
// using data from
// {{ .URL }}

package unihan

var UCDHan = map[string]string{
{{ range .Records }}
	{{ printf "%q" .Codepoint }}: {{ printf "%q" .Definition }},{{ end }}
}
`

var packageTemplate = template.Must(template.New("package").Parse(templateString))

var debug = flag.Bool("debug", false, "Enable to output to stdout instead of writing unihan.go")

func init() {
	flag.Parse()
}

func main() {
	b, err := getUnihanFile()
	if err != nil {
		log.Fatal(err)
	}

	zr, err := getUnihanZipReader(b)
	if err != nil {
		log.Fatal(err)
	}

	r, err := getUnihanReaderFromZip(zr)
	if err != nil {
		log.Fatal(err)
	}

	records, err := getUnihanRecords(r)
	if err != nil {
		log.Fatal(err)
	}

	data := struct {
		URL       string
		Timestamp time.Time
		Records   []UnihanRecord
	}{
		URL:       unihanURL,
		Timestamp: time.Now().UTC(),
		Records:   records,
	}

	var file io.WriteCloser

	if *debug {
		file = os.Stdout
	} else {
		if file, err = os.Create("unihan.go"); err != nil {
			log.Fatal(err)
		}
		defer file.Close()
	}

	if err := packageTemplate.Execute(file, data); err != nil {
		log.Fatal(err)
	}
}
