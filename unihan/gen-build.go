// The following directive is necessary to make the package coherent:

// +build ignore

// This program generates unihan.go. It can be invoked by running
// go generate
package main

import (
	"archive/zip"
	"bytes"
	"encoding/csv"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strings"
	"text/template"
	"time"
)

const unihanURL = "http://unicode.org/Public/UCD/latest/ucd/Unihan.zip"

type NoFileError string

func (e NoFileError) Error() string {
	return fmt.Sprintf("No file %q in the provided zip file.", string(e))
}

// getFileFromZip takes a io.ReadCloser corresponding to a zip file and
// the name of file inside of it, and returns a ReadCloser for that
// inner file and closes the outer file. Returns a NoFileError if it
// fails to find the file inside the zip or some other error if anything
// else goes wrong.
func getFileFromZip(src io.ReadCloser, filename string) (io.ReadCloser, error) {
	data, err := ioutil.ReadAll(src)
	if err != nil {
		return nil, err
	}
	src.Close()

	br := bytes.NewReader(data)
	zipReader, err := zip.NewReader(br, br.Size())
	if err != nil {
		return nil, err
	}

	for _, zf := range zipReader.File {
		if zf.Name != filename {
			continue
		}

		return zf.Open()
	}

	return nil, NoFileError(filename)
}

type UnihanRecord struct {
	Codepoint, Definition string
}

func getUnihanRecords(r io.Reader) ([]UnihanRecord, error) {
	reader := csv.NewReader(r)
	reader.Comma = '\t'
	reader.FieldsPerRecord = 3
	reader.Comment = '#'

	records := make([]UnihanRecord, 0)

	for {
		record, err := reader.Read()

		if err == io.EOF {
			return records, nil
		} else if err != nil {
			return nil, err
		}
		if record[1] == "kDefinition" {
			codepoint := strings.TrimPrefix(record[0], "U+")
			definition := strings.ToUpper(record[2])

			records = append(records, UnihanRecord{codepoint, definition})
		}
	}
}

const templateString = `// go generate
// GENERATED BY THE COMMAND ABOVE; DO NOT EDIT

// This file was generated by robots at
// {{ .Timestamp }}
// using data from
// {{ .URL }}

package unihan

var UCDHan = map[string]string{
{{ range .Records }}
	{{ printf "%q" .Codepoint }}: {{ printf "%q" .Definition }},{{ end }}
}
`

var packageTemplate = template.Must(template.New("package").Parse(templateString))

var debug = flag.Bool("debug", false, "Enable to output to stdout instead of writing unihan.go")

func init() {
	flag.Parse()
}

func main() {
	rsp, err := http.Get(unihanURL)
	if err != nil {
		log.Fatal(err)
	}

	r, err := getFileFromZip(rsp.Body, "Unihan_Readings.txt")
	if err != nil {
		log.Fatal(err)
	}

	records, err := getUnihanRecords(r)
	r.Close()
	if err != nil {
		log.Fatal(err)
	}

	data := struct {
		URL       string
		Timestamp time.Time
		Records   []UnihanRecord
	}{
		URL:       unihanURL,
		Timestamp: time.Now().UTC(),
		Records:   records,
	}

	var file io.WriteCloser

	if *debug {
		file = os.Stdout
	} else {
		if file, err = os.Create("unihan.go"); err != nil {
			log.Fatal(err)
		}
		defer file.Close()
	}

	if err := packageTemplate.Execute(file, data); err != nil {
		log.Fatal(err)
	}
}
